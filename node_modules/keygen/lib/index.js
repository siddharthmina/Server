(function() {
  /*
   * keygen
   * https://github.com/bitbutcher/keygen
   *
   * Copyright (c) 2015 Sean M. Duncan
   * Licensed under the MIT license.
   */
  var crypto, gen_for, large, medium, small;

  crypto = require('crypto');

  small = 11;

  medium = small * 2;

  large = medium * 2;

  gen_for = function(alpha) {
    var async, generate, it, sync;
    alpha = ((function() {
      var i, ref, results;
      results = [];
      for (it = i = 0, ref = 256 / alpha.length + 1; (0 <= ref ? i <= ref : i >= ref); it = 0 <= ref ? ++i : --i) {
        results.push(alpha);
      }
      return results;
    })()).join('').split('');
    generate = function(bytes) {
      var byte, i, key, len;
      key = '';
      for (i = 0, len = bytes.length; i < len; i++) {
        byte = bytes[i];
        key += alpha[byte];
      }
      return key;
    };
    sync = function(length) {
      var ex;
      try {
        return generate(crypto.randomBytes(length));
      } catch (error) {
        ex = error;
        return generate(crypto.pseudoRandomBytes(length));
      }
    };
    async = function(length, callback) {
      crypto.randomBytes(length, function(err, bytes) {
        if (err == null) {
          return callback(generate(bytes));
        }
        return crypto.pseudoRandomBytes(length, function(err, bytes) {
          return callback(generate(bytes));
        });
      });
    };
    return function(length, callback) {
      if ((length != null ? length.constructor : void 0) === Function) {
        [length, callback] = [callback, length];
      }
      if (length == null) {
        length = medium;
      }
      if (callback != null) {
        return async(length, callback);
      } else {
        return sync(length);
      }
    };
  };

  module.exports = {
    gen_for: gen_for,
    hex: gen_for('0123456789abcdef'),
    url: gen_for('23456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'),
    small,
    medium,
    large
  };

}).call(this);
